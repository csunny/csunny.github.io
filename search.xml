<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IPFS是什么?]]></title>
    <url>%2F2018%2F10%2F19%2FIPFS%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[前言相信很多人开始接触IPFS，首先会问，IPFS是什么， 它到底是干嘛的？ 如果我使用它，他能给我带来什么好处？又能创造怎么样的价值？ 结缘IPFS相比之下，我是比较幸运的。 我当时使用IPFS，正好是因为它可以解决我在开发中的使用场景。当时准备开发一个原创图片的内容分享网站。以下是当时项目的一些简单的描述： 创艺云平台项目计划 项目定位 创艺云平台基于区块链共识机制，采用区块链技术与智能合约来解决当前原创艺术图片内容系统中遇到的盗版、侵权等诸多问题，旨在开创一个创艺开发，互信，有偿的内容新天地。 创艺云平台整合创作版权方、需求方，通过区块链应用平台去中心化内容协议，赋予自身内容平台上所有用户更多的权益保障和能都，实现内容价值公平分配。 还有一个不成熟的商业模式。 还有半死不活的发展路线图 当然，前面这些都不是重点。重点是因为这个项目，我接触到了IPFS。IPFS解决了我对于图片的分布式存储，而不是存储在中心化的服务器上。 同时IPFS的MerkleDAG数据结构也保证了我数据的唯一、不可篡改。一次上传，永久有效，且能永久追踪。 深入研究由于以上背景，可以说IPFS深深吸引了我，后来就花了大量的时间来研究IPFS。从阅读IPFS白皮书开始，后来开始翻译白皮书，翻译文档。使用IPFS搭建个人博客，再到熟悉IPFS技术架构，阅读IPFS源码。这一路走来，IPFS给我留下了深刻的印象。尽管，目前为止，IPFS还有很多方面不够成熟，尽管IPFS还有很多代码没有写完。但，这丝毫不影响它独有的魅力与宏大的野心。 最近，随着IPFS整个项目的拆分与整理。IPFS彰显了更大、更宏伟的野心与梦想。正如IPFS官网所说，IPFS旨在取代HTTP，在我看来IPFS还能做更多。不管最终能否成功，我都会在这个过程中做一个参与者与见证人。 IPFS是什么？前面说了那么多，那么IPFS究竟是什么？ IPFS官网是这么描述的： IPFS is the Distributed Web， A peer-to-peer hypermedia protocol to make the web faster，safer，and more open. IPFS是分布式Web，是点对点的超媒体协议，可以让我们的web服务更快、更安全、更开放。 这里相信有很多人有疑问，既然说IPFS是下一代的web，那么它有什么区别，又有什么优势？ 其实在我看来，IPFS与传统web最本质的区别就是思维方式的区别。或者说IPFS是一种新的思维模式。 我们知道，在传统的web服务时代，我们寻找内容的方式是，首先知道存储文件的服务器地址(比如域名)然后通过服务器来查找自己需要的资源。当然，这里要提一下搜索引擎，因为有像google或者baidu这样的搜索引擎，所以在我们检索文件时，我们会错误的以为自己是根据内容寻地址(网站)。 而在IPFS的世界里，我们不需要知道文件存储的服务器地址，我们只需要文件的唯一指纹，就可以在全网进行查找我们需要的文件。所以IPFS是基于内容寻址的分布式WEB系统。 当然，除此之外，还有人说: IPFS是一种协议 定义一种基于内容寻址的文件系统 协调内容的分发 结合了Kademlia分布式Hash表+BitTorrent协议+git分布式文件系统 IPFS是一种文件系统 有文件夹和文件 可以进行文件挂载(通过fuse) IPFS是Web系统 可以用来像web一样浏览文档 可以通过HTTP请求的方式获取文件 哈希加密的地址可以保证内容的唯一性 IPFS是一个模块 在任何网络协议上的连接层 路由层 路由层使用分布式hash表 使用基于路径的命名服务 使用受到Bittorrent启发的块交换协议 IPFS使用了加密算法 内容地址是经过加密的哈希 数据块层的数据去重 文件压缩并打版本 文件层的加密和验证支持 IPFS是P2P网络 全球化的点对点文件传输 完全的分布式架构 不存在中心节点失效 IPFS是一种CDN网络 文件添加到本地文件系统，节点加入到IPFS对等网络就可以全球共享 友好的缓存 基于bittorrent的带宽分配 IPFS是一种命名服务 IPNS，受SFS启发的命名系统 基于PKI的全局命名空间 有助于建立信任链 和其他的NSes兼容 可以映射DNS，.onion .bit 等到IPFS How It Work？关于IPFS的使用，在本文中我就不介绍了，感兴趣的同学可以关注我的另一个专栏《EOS区块链技术开发》里面有几篇介绍IPFS详细使用的教程。IPFS个人博客，是我之前用IPFS写的一个个人博客系统。源码在我的github里面，作为一个简单的demo，欢迎大家交流。 总结以上就是我跟IPFS的结缘以及IPFS的简单介绍。最近随着IPFS开发者社区的不断壮大。IPFS项目被拆分成了很多子项目。典型的三个项目就是libp2p, 目前IPFS网络层跟路由层都拆分到libp2p当中。其次IPLD主要围绕MerkerDAG算法，承载了IPFS核心的数据结构。Bitswap是IPFS当中核心的数据交易所。这些项目目前都在快速发展着，代码更新相当活跃。]]></content>
      <categories>
        <category>IPFS</category>
      </categories>
      <tags>
        <tag>IPFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPFS使用教程及案例大全]]></title>
    <url>%2F2018%2F09%2F20%2FIPFS%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[简介此文档主要介绍IPFS项目、工具或者完全用IPFS构建的任何事物。 应用列表 js视频播放器 markdown渲染器 二维码渲染器 akasha 下一代的社交媒体网络，使用Ethereum和IPFS开发。 Alexandria 犯不是内容分发/货币化平台 Arbore 构建在IPFS之上的朋友之间的文件共享应用 Arpadyne 新的网络系统，由OrbitDB提供DNS，IPFS提供内容。 beets Beets有一个用IPFS开发的插件可以更简单地共享音乐库。 Blokaly 基于IPFS的徽章共享和发布平台。 Boards 运行在浏览器之上的分布式社交平台 Cohort 一个golang应用，对接threejs接口并从ipfs中获取内容。 Computes computer.io 是一个建立在ipfs之上的超级计算机。 digx 用以太坊和IPFS构建的数字资产管理平台。 dtube 基于steem的分布式视频分享应用，后端存储用IPFS。 enzypt.io 通过以太坊和IPFS购买销售文件的网站。 文章 HTTP已经过时了，是时候开始分布式、永久化WEB了 用IPFS实现分布式WEB应用的第一步 IPFS介绍 IPFS变更介绍 IPFS:网络民主化 用IPFS来进行IOT通信 为公共数据创建分布式索引 去中心化/分布式边缘计算computers.io超级计算机 理解IPFS白皮书-上 理解IPFS白皮书-下 面向未来的加密Hash IPFS中的内容标识 工具视频]]></content>
      <categories>
        <category>IPFS</category>
      </categories>
      <tags>
        <tag>IPFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPFS Repo 规范]]></title>
    <url>%2F2018%2F09%2F19%2FIPFS-Repo-%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[IPFS节点仓库规范。此规范定义了IPFS Repo, 它的内容，和他的接口。它没有指定实际如何存储数据，因为是通过热插拔的方式实现的。 定义]]></content>
      <categories>
        <category>IPFS</category>
      </categories>
      <tags>
        <tag>IPFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPFS keystore提案以及命令解析]]></title>
    <url>%2F2018%2F09%2F19%2FIPFS-keystore%E6%8F%90%E6%A1%88%2F</url>
    <content type="text"><![CDATA[目标拥有一种安全，简单且用户友好的方式来存储和管理ipfs使用的密钥对。同时能够共享密钥、加密、解密、签名和数据认证。 实施计划存储密钥将被存储路径在$IPFS_PATH下在名为keys的字典中。每一个密钥对都会存储在两个文件中，私钥文件$NAME和公钥文件$NAME.pub. 他们将被加密为PEM(或相似)的格式，并且可选密码加密。 一旦启动ipfs daemon， 密钥将按需延时加载。如果给的密钥是受密码保护的，在加载密钥时应提醒用户输入密码。$IPFS_PATH/keys文件夹因为是owner唯一可读，并且权限是700。密钥应该被owner唯一可读，并且权限是400。 接口需要对IPFS工具链进行一些添加和修改以适应变更。首先创建两个ipfs子命令 ipfs key 和 ipfs crypt 12345678910111213141516 ipfs key - Interact with ipfs keypairsSUBCOMMANDS: ipfs key gen - Generates a new named ipfs keypair ipfs key list - Lists out all local keypairs ipfs key info &lt;key&gt; - Get information about a given key ipfs key rename &lt;key&gt; &lt;name&gt; - Rename a given key ipfs key show &lt;key&gt; - Print out a given key ipfs rm &lt;key&gt; - Delete a given key from your keystore ipfs key send &lt;key&gt; &lt;peer&gt; - Shares a specified private key with the given peer Use 'ipfs key &lt;subcmd&gt; --help for more information about each command.'DESCRIPTION:'ipfs key' is a command used to manage ipfs keypairs. 12345678910 ipfs crypt - Perform crytographic operations using ipfs keypair.SUBCOMMANDS: ipfs crypt sign &lt;data&gt; - Generates a signature for the given data with a specified key ipfs crypt verify &lt;data&gt; &lt;sig&gt; - Verify that given data and signature match ipfs crypt encrypt &lt;data&gt; - Encrypt the given data ipfs crypt decrypt &lt;data&gt; - Decrypt the given dataDESCRIPTION: `ipfs crypt` is a command used to perform various cryptographric operations using ipfs keypairs, including: signing, verifying, encrypting and decrypting. 一些子命令Key Gen12345678910 ipfs key gen - Generate a new ipfs keypairOPTIONS: -t, -type string - Specify the type and size of key to generate -p, -passphrase string - Passphrase for encrypting the private key on disk -n, -name string - Specify a name for the keyDESCRIPTION &apos;ipfs key gen&apos; is a command used to generate new keypairs. IF any options are not given. the command will go into interactive mode and prompt the user for the missing fields. 注释与ssh-keygen类似。 key send1234567891011121314151617 ipfs key send &lt;key&gt; &lt;peer&gt; - Send a keypair to a given peerOPTIONS: -y, -yes bool - Yes to the promptDESCRIPTION: &apos;ipfs key send&apos; is a command used to share keypairs with other trusted users. It will first look up the peer specified and print out their information and prompt the user &quot;are you sure? [y/n]&quot; before sending the keypair. The target peer must be online and dialable in order for the key to be sent. Note: while it is still managed through the keystore, ipfs will prevent you from sharing your nodes private key with anyone else.` Crypt Encrypt1234567891011121314151617ipfs crypt encrypt &lt;data&gt; - Encrypt the given data with a specified keyARGUMENTS: data - The filename of the data to be encrypted (&quot;-&quot; for stdin)OPTIONS: -k, -key string - The name of the key to use for encryption (default: localkey) -o, -output string - The name of the output file (default: stdout) -c, -cipher string - The cipher to use for the operation -m, -mode string - The block cipher mode to use for the operationDESCRIPTION: &apos;ipfs crypt encrypt&apos; is a command used to encypt data so that only holders of a certain key can read it. 其他的接口变更我们还需要在其他命令中支持密钥，比如: ipfs add 支持–encrypt-key 操作, 用于块加密使用密钥添加的文件 也可以添加 ‘encrypted’ 节点在上面的跟unixfs节点 支持 -sign-key操作, 从unixfs跟节点获得签名节点 ipfs block put 支持 -encrypt-key 操作。 用于在散列和存储之间加密块。 ipfs object put 支持 -encrypt-key 操作, 用于在散列和存储之间加密对象。 ipfs name publish 支持 -key操作，选择要发布到哪个密钥空间。 代码更改/添加Repo- 添加keystore概念到repo, 安全的加载或存储密钥 - 需要理解PEM编码 12345678910type KeyStore interface &#123; // Get a key from the cache GetKey(name string) (ci.PrivKey, error) // Save a new key into the cache, and write to disk StoreKey(name string, key ci.PrivKey) error // LoadKey reads the key from its file on disk, and stores it in the cache LoadKey(name string, password []byte) error&#125; Unixfs 新节点类型 结构用于签名和加密的新DAG结构的一些临时模型(json表示)签名的DAG12345678910111213&#123; "Links": [ &#123; "Name": "@content", "Hash": "QMthecontenT", &#125; ], "Data": protobuf&#123; "Type": "Signed DAG", "Signature": "thesignature", "PubKeyID": "QimPubKeyHash", &#125;&#125; 加密的DAG12345678910111213&#123; "Links": [ &#123; "Name": "@content", "Hash": "QmRawEncryptedDag", &#125; ], "Data": protobuf&#123; "Type": "Encrypted Dag", "PubKeyID": "QmpubKeyHash", "Key": "emphemeral symmetric key, encrypted with public key." &#125;&#125;]]></content>
      <categories>
        <category>IPFS</category>
      </categories>
      <tags>
        <tag>IPFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keychain概述及实现]]></title>
    <url>%2F2018%2F09%2F19%2FKeychain%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[简介此文档介绍keychain, 一个分布式的merkle-linked 数据结构，链接加密的密钥、身份、验签、证书、密文、证明和其他的对象。 keychain提供了一种普通的构造来管理分布式的密钥和证书。 它跟公钥的基础设施类似，但进一步将对象做了绑定。 1234567891011121314151617181920212223242526272829303132// Identity represents an entity that can prove possession of keys.// It is meant to map to People. Groups, Processes, etc. It is // essentially a Provertype Identity struct &#123; Name string // does not need to be unique.&#125;// Key represents a cryptographic keytype key struct&#123; Algorithm Link // the algorithm used to generate the key Encoding Link // the encoding used to store the key Bytes Link  // the raw key bytes&#125;// Key pair represents a pair of keys.type Keypair struct &#123; Public Link // the public key Secret Link // the secret key&#125;// Signature represents a digital signature over another objecttype Signature struct &#123; Key Link // the key used to verify this signature(PublicjKey) Algorithm Link // the algorithm used to sign the signee Encoding Link // the encoding the sig is serialized with Signee Link // the object the key is signing Bytes Data // the raw signature bytes&#125;// Ciphertext represents encrypted datatype Encryption struct &#123; Decryptor Link // the identity able to decrypt the encrytion Ciphertext Link // the encrypted data&#125; proof 类型1234567891011// proofOfControl proves a certain key is under control of a provervar ProofOfControl = "proof-of-control"// ProofOfWork proves an amount of work was expended by a prover.var ProofOfWork = "proof-of-work"// ProofOfStorage proves certain data is possessed by prover.var ProofOfStorage = "proof-of-storage"// ProofOfRetrievability proves certain data is possessed by _and retruevable from _ a prover.var ProofOfRetruevability = "proof-of-retruevability" 图解]]></content>
      <categories>
        <category>IPFS</category>
      </categories>
      <tags>
        <tag>IPFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DEX概述及实现]]></title>
    <url>%2F2018%2F09%2F19%2FDEX%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[简介IPFS数据导入规范描述了IPFS使用的几种数据导入的机制，这些机制也可以被其他系统使用。 一个导入机制由一个或者多个chunkers和数据格式组成。 介绍将数据导入到IPFS可以通过几种方式来完成。 对于不同的用例，可以生成不同的数据结构，不同的图拓扑等等。 这些在IPFS的实现中，并不是严格要求的，但绝对可以让其更有用。 这些数据导入原语实际上只是IPLD之上的工具，这意味着可以是通用的，与IPFS本身分开。 实际上，数据导入被分为两部分: Layouts ——数据组织和表示的图拓扑结构，其中包括 平衡图，更易实现 trickledag, 为搜索优化的自定义图 实时流 数据库索引 等等 分配器 —— 应用与每个文件的分配算法，可以是： 固定大小的分块 rabin 指纹识别 专用格式分块，需要知道文件格式，并且通常只适用特定的文件(视频、音频、图片等) 特殊数据结构分块，像tar,pdf,doc,容器或者虚拟镜像。 目标有一组基元来消化、分块以及解析文件，所以不同的块可以被替代或者添加不会出现任何问题。 要求为了实现布局和分配器，需要满足以下要求: layout应该暴露编码/解码API，目的是为了转化数据格式为其需要的格式或者转化为原始格式。 layout 应该包含转换为其格式的清晰的无模式表达 layout可以利用一个或者多个分配器策略，根据数据格式应用最佳策略 分配器 无模式 —— 以相同的方式组块任何格式 专用 —— 仅适用与特定的格式 分配器也应该暴露编码/解码API 分配器，一旦输入数据，就应该能生成自己的layout以及要添加块的layout 导入器是layout和分配器的结合。 架构12345678 ┌───────────┐ ┌──────────┐┌──────┐ │ │ │ │ ┌───────────────┐│ DATA │━━━━━▶│ chunker │━━━━━━━▶│ layout │━━━━━━━▶│ DATA formated │└──────┘ │ │ │ │ └───────────────┘ └───────────┘ └──────────┘ ▲ ▲ └─────────────────────────────────┘ Importer 接口Splitterslayoutimporter 实现chunker go-chunker https://github.com/jbenet/go-chunk layoutimporter 参考 https://github.com/ipfs/specs/tree/master/dex]]></content>
      <categories>
        <category>IPFS</category>
      </categories>
      <tags>
        <tag>IPFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitswap原理及实现]]></title>
    <url>%2F2018%2F09%2F18%2FBitswap%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[简介Bitswap是IPFS的数据交易模型。它的目的是用来从其他节点请求或发送数据。Bitswap有两个主要的功能 尝试从网络中获取已被客户端请求的数据。 发送自己所拥有的数据给需要的节点。 介绍Bitswap是IPFS的中心块交换协议。它处理IPFS用户、普通用户以及应用的请求，从网络中获取数据。它用来跟其他节点的Bitswap相互通信来交换彼此所需的数据。Bitswap是基于消息的协议，而不是回复。所有的消息包含需求清单、数据块。在接收到需求清单之后，IPFS节点或发出其拥有的数据给需求方。当接收到数据块之后，节点应该发送一个Cancel通知表明它不再需求相应的数据块。在协议层Bitswap是相当简单。 尽管Bitswap是一个相当简单的协议，考虑到时间和内存性能，也有很多值得关注的点。我们的目的是在这里尽量详细的记录这些，为了将来实现的时候可以不断迭代。 子系统在Bitswap管理中两个主要的流程： 从其他节点请求数据和发送数据给其他节点。 数据块请求主要由需求管理员来调节，它告诉节点是否我们需要新的数据块。发送数据块主要由决策引擎处理，它决定了如何在节点之间进行资源分配。 类型如下描述的类型是Bitswap子系统中描述的。 CID: 使用特定数据块的内容寻址标识符 Peer: 链接的另外的Bitswap实例 Block： 二进制blob Message： Bitswap 消息 Entry：在需求列表中，添加/删除特定的CID时可能包含在消息中的需求列表，其中包括 CID 一个特定的块 Priority 用户想要的CID的优先级 Cancel 一个bool值，旨在从我们的需求列表中删除CID。 Ledger：两个节点之间数据交换的聚合值。每个节点为其他节点存储一个Ledger。 Bitswap消息单个Bitswap消息可能包含以下任意内容 发件人的需求清单。此需求列表可能是发件人完整的需求列表，也可能仅仅是接收者需要知道的需求列表。 数据块。这些是接收者请求的数据块。 消息格式 message Message{ message Wantlist { message Entry{ optional string block = 1; // the block key optional int32 priority = 2; // the priority (normalized). default to 1 optional bool cancel = 3; // whether this revokes an entry } repeated Entry entries = 1; // a list of wantlist entries. optional bool full = 2; // whether this is the full wantlist. default to false. } optional Wantlist wanlist = 1; repeated bytes blocks = 2; } 需求管理者需求管理者处理块请求。对于请求的块，通过cid认证，Bitswap.GetBlock(cid)方法被调用。Bitswap.GetBlock(cid)从网络中请求cid，如果收到相应的块，则返回。更具体来讲，Bitswap.GetBlock(cid)添加cid到需求列表中。需求管理者通过向每个节点的消息队列中添加条目来更新所有节点。 决策引擎决策引擎如何在节点之间分配资源。当接收到一个需求列表时，消息会发送给决策引擎。对每一个需求列表中的CID，都有相应的块，块有一个任务添加到任务队列。一旦块被发送到节点的消息队列中，我们认为任务已经完成了。 在决策引擎中主要的数据结构是节点请求队列(PRQ)。PRQ添加节点到加权队列中，其中权重基于对一个或者多个节点的度量。这也是Bitswap策略的来源。当前，策略是一个函数，它的输入是ledger，输出是节点的权重。然后节点在各自的任务队列中提供任务。在给定的循环轮次中，每个节点的数据量由它们在队列中的秀昂队权重确定。 消息队列每一个激活的节点都有一个相应的消息队列。消息队列保存要发送给节点的下一条消息。消息队列从其他的子系统中接收更新。 需求管理者：当CID从需求列表添加或删除时，我们必须更新节点。这些需求列表的更新被发送到其他所有节点的消息队列中。 决策引擎：当我们拥有节点需要的块，并且决策引擎决定发送这个块，我们广播这个块到其他节点的消息队列。 任务工作者观察消息队列，将消息从队列中出列，并且发送给相应的接收者。 网络网络是表示通过一个或多个链接到我们的所有Bitswap节点的抽象。Bitswap消息流流入或流出的网络。在一个任意的网络中，我们必须假设我们所有的同伴都是理性的和自私的。 实现细节消息合并当已包含Bitswap消息的消息队列收到另一个消息队列时，新的消息应该与原消息合并，以减少发送单独数据包的开销。 Bitswap会话Bitswap会话是尝试优化发送到其他Bitswap客户端的块请求。当从网络中请求块图时，我们发送一个需求清单去更新包含根块给所有的节点。对于每个发送根块的节点，我们将此节点添加到图的激活集中。然后我们将图中的其他节点的所有请求发送到活动集中的节点。拥有图根节点的节点可能也会拥有其子节点，同时没有根节点的节点可能没有子节点。 实施建议 维护一组“在线合作”节点 协议侦听器接受伙伴接受消息流 协议发送方向合作伙伴打开流发送消息 分离出一个决策引擎，选择将哪些块、在何时、发送给哪些节点。 Sender 打开bitswap流 发送一个或多个bitswap消息 关闭bitswap流 Listener 接受bitswap流 接受一个或多个bitswap流 关闭bitswap流 Events bitswap.addedBlock(block) 观察是否有任何节点需要此块，并发送 bitswap.getBlock(key, cb) 添加到需求列表 可能会发送需求列表更新到其他节点 bitswap.cancelGet(key) 需求列表取消 bitswap.receivedMessage(msg) 处理需求列表变更 处理块 bitswap.peerConnected(peer) 添加节点 bitswap.peerDisconnected(peer) 移除节点 Tricky Bits 客户端bitswap可能会调用getBlock 然后cancelBlock 合作伙伴可能会发送垃圾邮件 针对每个用户的标准化优先级 Modules bitswap-decision-engine bitswap-message bitswap-net bitswap-wantlist Notes var bs = new BlockService(repo, bitswap) bs.getBlock(multihash, (err, block)=&gt;{ // try to fetch from repo // if not -&gt; ask bitswap // bitswap will cb() once the block is back, once. // bitswap will write to the repo as well. }) 实现 Go语言实现 js实现]]></content>
      <categories>
        <category>IPFS</category>
      </categories>
      <tags>
        <tag>IPFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPFS架构概述]]></title>
    <url>%2F2018%2F09%2F17%2FIPFS%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[目录 IPFS and Merkle DAG Nodes and Network Model The Stack Applications and Datastructure - on top of IPFS Lifetime of fetching an object IPFS User Interfaces IPFS 和Merkle DAGIpfs的核心是MerkleDAG，是一个连接为hash值的有向无环图。这为IPFS中的所有对象都提供了如下特性: 认证 - 内容可以做hash运算并且可以通过连接hash值做反向验证。 持久 -一次拉取，永久缓存。 普适 - 任何数据结构都可以用merkledag来表达 去中心化 - 对象可以被任何人创建，而不需要集中的写入者。 反过来，这些特性使得系统具有如下优势： 连接是根据内容寻址的 对象可以由不受信任的服务提供 对象可以被永久缓存 对象可以被离线创建或使用 网络可以分区和合并 任何数据结构都可以建模并分发 IPFS是一个网络协议栈，用来组织代理网络来创建、发布、分发、服务和下载Merkledags，它是自证的、去中心化的、永久的web系统。 节点和网络模型IPFS 网络使用基于PKI的身份认证。一个ipfs节点是一个程序包含查询、分发、和复制MerkleDag 对象。其标识由私钥定义。比如： privatekey, publicKey := keygen() nodeID := multihash(publicKey) MultiHash and upgradeable Hash 在ipfs中所有的hash都被multihash编码，multihash是一个自描述的hash格式。 实际hash函数的使用，依赖与安全的需求。IPFS加密系统是可升级的，意味着hash函数出问题之后，网络可以迁移到更强壮的hash。天下没有免费的午餐，因为对象可能需要重新计算hash值，或者链接重新复制。 但是要确保不要假设原先预定义的hash长度可以适应未来的hash函数。 sha2-256 sha2-512 sha3 技术栈IPFS有一个模块化的技术协议栈。每一层都有多个实现。此规范仅仅定义层之间的接口，以及简要提及可能的实现。 IPFS有5层： 命令空间(naming) - 自证的PKI命名空间（IPNS） MerkleDag - 数据结构格式(thin waist) 交换 - 块交换和复制 路由 - 本地节点和对象 网络 - 在节点之间建立链接 这是一个从下到上的简易描述。 网络网络提供点对点的传输在两个节点之间（可信或者不可信）。 主要处理： NAT遍历 - 打孔、端口映射和中继 支持多种传输协议 - TCP、 SCTP、UTP… 支持加密，签名或清除通信 支持加密、签名和清除通信 多路复用 - 连接复用、协议复用、peer复用 路由 — 发现节点和数据IPFS路由层有两个重要的目的 节点路由 -找出其他节点 内容寻址 -查找分发到ipfs上的数据 路由系统是满足各种实现的接口，比如： DHTs mdns snr dns 块交换 — 传输内容寻址的数据IPFS 块交换负责批量数据的传输。一旦节点之间相互连接并且认证之后，交换协议就开始传输数据。 块交换是满足以下实现的接口。比如： Bitswap - IPFS中主要的交换协议。 HTTP - 一个简单的通过HTTP客户端和服务端实现的交易。 MerkleDag正如前面提到的，IPFS merkleDag 是IPFS核心的数据结构。它是边为hash值的有向无环图。它的另一个名称是Merkleweb。 Merkledag 数据结构如下所示： message MDagLink{ bytes Hash = 1; // multihash of the target object string Name = 2; // utf string name. should be unique per object uint64 Tsize = 3 ; // cumulative size of target object } message MDagNode { MDagLink Links = 2; //refs to other objects bytes Data = 1; //opaque user data } Merkledag 是认证的“瘦腰”数据结构。它是最小的表示+传输任意认证数据结构的数据结构。更加复杂的数据结构都是利用merkledag来实现的。比如： git 以及其他的版本管理系统 bitcoin 和其他的链 unixfs 一个内容寻址的文件unix 文件系统 MerkleDag 路径merkledag足以解决路径问题 /ipfs/QmdpMvUptHuGysVn6mj69K53EhitFd2LzeHCmHrHasHjVX/test/foo (a) 首先会获取+解析QmdpMvUptHuGysVn6mj69K53EhitFd2LzeHCmHrHasHjVX (b) 然后查询(a)的链接，找到test的哈希，并解析 (c) 然后查询(b)的链接，找到foo的哈希，并解析 命名 ——PKI命名空间和可变指针IPFS主要关注内容寻址，这本质上是不可变的。改变一个文件也会改变它的hash值，也就改变了其地址，使它成为一个完全不同的对象。(可以把它想象成一个写时复制的文件系统) IPFS命名层 — 或者IPNS 指向对象的可变指针 人类可读的名称 IPNS是基于SFS的。 它是一个PKI命名空间。名称只是公钥的hash值。掌控私钥的人掌控名称。记录被私钥签名并且分发(在IPFS中，通过路由系统)。这是在互联网上实现的一种基于平均主义的分配方式。即没有中心化的机构，也不存在证实颁发部门。 应用和数据结构——在IPFS的上层到目前为止描述的技术栈足以用来表示任意的数据结构并在互联网上复制它们。同时也已经足以构建和部署去中心化的网站。 在IPFS上的应用和数据结构用merkledag来表示。用户可以创建任意的数据结构并且部署在全世界。 Unixfs —代表传统的文件unix文件系统抽象 ——文件和目录——是人们在互联网上构建文件的主要方式。在IPFS中unixfs是表示IPFS之上的unix文件的数据结构。我们需要一个独立的数据结构来传递信息。 对象或者目录 总大小，减去索引的开销 获取对象的生命周期假设我们IPFS中获取以下数据 ipfs/QmdpMvUptHuGysVn6mj69K53EhitFd2LzeHCmHrHasHjVX/test/foo IPFS 节点首先将路径拆分成如下形式： [ &quot;QmdpMvUptHuGysVn6mj69K53EhitFd2LzeHCmHrHasHjVX&quot;, &quot;test&quot;, &quot;foo&quot; ] 然后IPFS节点解析组件。第一个组件是/ipfs/… path总是multihash值，剩下的就是链接名称。 IPFS用户接口IPFS不仅仅是一个协议。它是一个工具集。IPFS实现包括处理Merkle的各种工具，如何部署、如何命名等等。这些接口可能对实现或整个项目的生存至关重要。这些接口控制人们如何使用IPFS。因此必须特别注意其设计和实现。比如： IPFS api - 一个HTTP服务 IPFS cli - 一个unix 命令 IPFS libs - 各种语言的实现 The IPFS gateways - 互联网中通过IPFS提供的HTTP节点]]></content>
      <categories>
        <category>IPFS</category>
      </categories>
      <tags>
        <tag>IPFS</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习路线浅谈]]></title>
    <url>%2F2018%2F09%2F12%2FPython%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E6%B5%85%E8%B0%88%2F</url>
    <content type="text"><![CDATA[简介:Python作为炙手可热的语言，在Web开发、DevOps、数据分析、AI等领域都有优秀的表现与广泛的应用。我作为一个多年的Pythoner，简单梳理一下Python语言的学习路线。 Python语言的学习，我自认为跟学习其他语言没多大区别。相反Python由于简洁的语法，优雅的设计。更容易让初学者上手。 我自认为学好Python需要经历以下阶段: 一、Hello World，与基础语法Python的安装运行，能够配置好一个可以写代码的环境，这里面包括 Python的安装 代码编辑器的安装  初学者推荐(pycharm,后面切换成vscode) 写一个hello world程序并成功运行 过一遍W3Cshool上的Python基础教程 如果做完了上面的部分，廖雪峰老师的Python系列教程是值得过一遍的。另外推荐基本Python非常经典的基本书籍： Python编程基础 Python CookBook3 流利的Python 上面提到的书籍不一定要一次看完，这几本书相当有用，可以作为参考数目，时常翻来看看。我每次重新阅读都感觉收获颇多。 二、代码实战有了前面的基础，实战就非常重要了，因为只有实战才能真的掌握这项技能。就编程这项技能来说，实战永远是很重要的。 所以这个阶段可以写代码。打基础的话，我推荐以数据结构与算法为主. 下面是Github上我写的Python数据结构与算法的一个开源项目。很基础，也很完善。非常适合python代码实战。Python数据结构与算法 数据结构与算法只能熟悉Python语法、以及锻炼思维逻辑。但还不够，需要写几个项目。 初期我认为以小项目为主。推荐写类似博客系统或者图书管理系统等简单的工程。这个过程中推荐使用一些开源的框架。比如flask、django等web框架。 如果以上都掌握了，那么尽可能的加入到一些team里面吧，因为初学者一般不知道自己可以用哪些项目来锻炼自己，项目组里面会有人给你分配任务，带你升级打怪。 三、阅读源码、研究架构做完前面两点，相信你已经是一个合格的程序员了，这时候就需要对语言对技术进行进一步的挖掘，所以需要看源代码。 主要研究几个比较优秀项目的源代码。 当然，读源代码的过程中我相信一定会遇到很多问题，因为这个阶段之后，技术已经不是单一的Python语言层面了，它会涉及到很多方面。网络啊、存储啊、算法啊、架构啊等等一系列的知识。这里也有一个研究源码来利用python实现的开源项目，欢迎交流。Python比特币实现 四、博览群书做到前面几点，我相信你已经是一个高级程序员了，接下来就要朝着资深、专家迈进了。当然，难度也会有显著的提升。需要阅读大量的书籍，需要对公司业务、技术结构等等各方面都有了解。 正因此，这个阶段需要博览群书，当然这里的书不仅仅局限于书本。还有很多其他任何在技术领域值得学习与提高的东西。 五、迈向卓越如果坚持下来，一直进步，到这一步，已经把很多人甩到后面了。换句话说，在编程这个领域已经算是专家级别的高手了。至于成为专家之后怎么发展。嗯，我也不知道。总之已经很棒了，你的思维模式也已经能够独立思考来让你自己规划接下来的目标与思路了。 六、总结其实前面说了那么多，都不是重要的。最重要只有四个字： 坚持、行动！]]></content>
      <categories>
        <category>编程语言 - Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链底层技术学习路线]]></title>
    <url>%2F2018%2F09%2F11%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%95%E5%B1%82%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[简介区块链作为一个新的词汇，在技术层面可以简单的划分为应用层的技术跟底层技术。通常讲应用层的技术，指的是Dapp(区中心化的应用程序或web程序)、应用钱包等等。而底层技术通常来说是指私链、公链或者联盟链。当然完全这样来划分或许并不准确，但这仅仅是一个表达的纬度。而底层技术层面又包含很多细分的技术。比如: 加密算法、数据结构、P2P网络、分布式存储、交易&amp;交易模型、虚拟机等等。同时区块链底层技术由于目前很多都还处于研发实验阶段，所以在研读区块链底层技术时不仅仅需要关注代码，还要理解白皮书里面阐述的设计思想与哲学。由于绝大多数区块链项目都是由一篇白皮书开始的，所以阅读并能实现白皮书中的设计思想，是区块链底层技术的核心也是必要条件。 区块链底层技术不仅涵盖内容广泛、技术难度高，而且需要绝对安全。正是因为此，区块链底层技术也充满了活力与魅力，而我正在学习、实践的路上，也希望成为一名技术geek! 基础编程语言 Go语言 C++ 数据结构 基础数据结构与算法 Go语言数据结构与算法基础 Python数据结构与算法基础 MerkleTree 默克尔树 MerkleDAG 加密算法 Base58加密算法 Hash加密算法 椭圆加密算法 分布式共识算法 PoW(Proof of Work)工作量证明算法 PoS(Proof of Stake)权益证明算法 DPoS(Delegated Proof of Stake)委托权益证明算法 交易模型 UTXO交易模型 账户模型 网络 HTTP&amp;Restful API基础理论及实践 RPC&amp;gRPC基础理论与实践 P2P对等网络基础理论与实践 分布式Hash表简易实现 分布式Hash表简易实现——上篇 分布式Hash表简易实现——下篇 分布式存储 IPFS IPFS基础入门 IPFS设计哲学 开发一个基于IPFS的个人博客系统 进阶 实现一条简易的比特币公链 虚拟机&amp;解析器 EVM以太坊虚拟机 LLVM Clang 论文&amp;白皮书 比特币项目白皮书 以太坊项目白皮书 EOS项目白皮书 Fabric项目白皮书 IPFS项目白皮书 源码&amp;技术架构 BTC技术架构及源码 ETH技术架构及源码 Hyperledger Fabric技术架构及源码 EOS技术架构及源码 IPFS技术架构及源码]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>区块链底层技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话Go语言]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%A4%A7%E8%AF%9DGo%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[2009年，go语言诞生了！正如历史上其他一切新事物一样，go也有它自己的梦想与使命。2009年，我自认为不管是在计算机软件发展史、还是在人类发展史上，都是一个相当重要的年份。2008年金融危机爆发，经济下行全球产生信任危机。从此绝大多数行业开始走向转折，互联网行业跟随时代的步伐，异军突起，开始了草莽式的发展。 正是在这样的历史时刻，go语言作为google的金宝贝（golden son）在一批大牛的怀抱中诞生了，诞生之初就自诩为互联网时代的C语言。然而，也正是这一年，在另一边的芬兰赫尔辛基，中本村用C++语言实现了比特币的代码，挖出了世界上第一枚比特币。 历史总是惊人的巧合，或许在当时没人能够想到，这两个完全不同的事情，对人类发展史有如此重大的影响。 现如今，go跟c++作为区块链底层技术领域的双雄，正在改变历史。 或许今天，这种改变你可能还没意识到，或者没体会到，但我要告诉你，Time is changed！ 当然了，go语言诞生的本意并不是成为区块链底层技术开发的主流语言，就像我前面提到的，它有自己的梦想与使命。08年前后，随着互联网的高速发展，对网站的性能提出了越来越多的挑战，所以并发与分布式成为了工程师们关注的焦点。 此外不同与传统的大型服务器，互联网行业一方面为了适应高速发展的需求，同时降低资源成本，多核化与集群化是互联网时代的典型特点。go语言作为互联网时代诞生的语言，一开始就顺应时代，天然支持高并发。 经过这么多年的发展之后，技术工程师们希望在保持高性能的基础上，在开发使用方面也能够保持足够的轻量、简单，同时又能适应大规模的软件工程开发工作。所以工程师们带着这些要求，重新出发，在借鉴前人的基础上，又推翻了之前存在的很多东西，另辟蹊径，终于在2009年，go语言出现在了我们面前。 不同于其他绝大多数语言，由于go语言本身就出身在大户人家，所以天生就发育良好。到2013年，docker的出现吹响了go语言开疆扩土的号角。此后随着k8s、 docker-swarm 等一批基于pass平台的技术出现之后，go语言正式成为了云计算领域的绝对主角。好巧不巧，同样也是在2013年，ethereum基金会成立，融资开发ethereum平台，2015年随着ethereum的发布上线，ethereum成为了比特币之后第二影响力的公链。而让人兴奋的是，ethereum是基于go语言开发的，从此go语言跟C++一样成为了区块链底层开发技术的不二之选。 今年是2018年，go语言已经应用在了很多产品当中，同时也有很多杀手级的应用。 谁也无法阻止历史的车轮，未来的事情会是怎么样，我们谁都无法预测。但，在当下，go语言作为高并发与分布式系统领域最炙手可热的语言，值得我们去学习，去钻研，去探讨！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Go语言</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[群雄逐鹿的大航海时代,谁将定义区块链未来的样子？]]></title>
    <url>%2F2018%2F09%2F10%2F%E7%BE%A4%E9%9B%84%E9%80%90%E9%B9%BF%E7%9A%84%E5%A4%A7%E8%88%AA%E6%B5%B7%E6%97%B6%E4%BB%A3-%E8%B0%81%E5%B0%86%E5%AE%9A%E4%B9%89%E5%8C%BA%E5%9D%97%E9%93%BE%E6%9C%AA%E6%9D%A5%E7%9A%84%E6%A0%B7%E5%AD%90%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[题记：相比站在岸上被媒体与软文支配的人们，我更敬佩那些在船上竞争与搏杀的人们，他们不仅是最具发言权的人，而且最终会决定这个行业的走向！ 币圈暴跌，流言四起，在一片归零的吆喝声中，更慌的反而是各路媒体与站在岸上的人们。 没有人知道区块链应有的模样，但大家都在努力让其成为自己“梦“中的样子。 2008年，比特币出世，中本聪在白皮书中描述了一种基于Pow(工作量证明算法)的点对点去中介化数字支付方式，中本聪利用节点之间通过共识算法去除中间机构的方式，向我们展示了区块链技术在他心中的样子。截止目前，已经有数千万人亲身参与其中，有数亿人被比特币这个词所影响。 2013年，V神提出以太坊，正如其白皮书所言《下一代智能合约和分布式应用平台》,其在2013年提出开始募资开发，到2015年上线。截止目前，以太坊上已经出现了数万基于代币的智能合约，撑起了整个ICO市场，此外，基于以太坊的分布式应用也如火如荼。虽然截止目前其还被诟病没有真正落地的应用，但也切切实实的影响了数千万的参与者以及数万开发人员。它在币市上也一直牢牢占据着第二的位置，至今无人撼动。 “下一代智能合约与分布式应用平台” 我想这就是V神心中区块链技术的样子。 2014年，IPFS诞生了。一位来自墨西哥的小伙子Juan Benet发明了IPFS。正如绝大多数天才一样，他不仅有着亮眼的履历与背景，毕业于举世闻名的斯坦福大学，在2015年参与了大名鼎鼎的Ycombinator计划，并成功创办了Protocol Lab实验室，而且怀揣改变世界的梦想。由于对HTTP在分布式技术领域的表现越来越不满，为了在新的时代有一种更为高效的技术，来应对更多的挑战。IPFS站在巨人的肩膀上，集众家之所长，成为了区块链领域，尤其是区块链存储领域炙手可热的技术手段与解决方案。或许一开始IPFS并不是为了区块链而服务，但是直到2017年，Juan Benet引入区块链技术的激励机制，通过引入Token的方式，真正让这项技术有了更完善的商业逻辑。至此，Juan Benet给我们勾勒出了区块链在他心中的样子。 相比公链的自由与火热，联盟链来的稍微晚了一些。但对于一个伟大的时代，梦想家们或许会迟到，但绝不会缺席。如果说2015年，IBM 《超级账本：一个联盟链分布式操作系统》论文发布预示了区块链技术进入大公司的视野，那么2016年Linux基金会主导的Hyperledger开源合作项目成立，正式向世人宣布，在区块链大海航时代，以大公司利益出发的联盟链正是加入了这场伟大的航行之中。他们也希望在这个时代来定义区块链的样子，在大海最深处，冰山最险地，插上自己鲜艳的旗帜。虽然，跟更为普惠的公链不同，但大公司们以联盟链的形式，像我们描绘着区块链在他们心里的样子。 如果说以上种种都没有引起大家的注意，那么我相信起始于2017年的EOS一定让大家印象深刻。《EOS: 最强大的分布式应用操作系统》。与之前的区块链公链相同的是EOS也受到了诸多争议，但不同的是，这种争议在EOS身上表现的更为激烈。不仅仅是对于EOS这个项目，甚至很多人将矛头指向了EOS开发者——BM。尽管在EOS之前BM已经在BTS跟Steem两个项目上取得了巨大的成功，但抛弃BTS跟Steem转向EOS的行为，给BM以及EOS都造成了诸多困扰。在了解BM的过程中，我们看到他的愿景，构建一个系统，可以保护我们的人身、财产安全。同时在他对于金规与银规的阐述中，他所坚持的，仅仅做到“己所不欲、勿施于人”是不够的。“如果我们想让这个社会怎么对我们，我们就去怎么对待它。” 才是BM所坚持的。尽管这种论调在EOS的涨跌中被批判的体无完肤，但BM还是一直在努力向世人构建区块链在他心目中的样子，无关肯定或质疑。当然，EOS一开始就是一个有所妥协的项目，其Dpos共识算法充分体现了这一点，但我想，BM不是为了梦想而妥协，他只是妥协与这个时代。 不像纯粹的技术领域，区块链技术由于天生的金融属性，在这个领域有更多的声音，很杂，很杂。无论你作出什么样的举动与判断，无论对错，都会有人来指责跟嘲笑。 我喜欢看《海贼王》，在前海贼王之后的大海贼时代，属于旧时代的海贼和站在岸边的人们嘲笑着大海上为梦想奋斗的航行者。他们仅仅能从报纸上或者岸边看到一点海上的风景，然后在那里或批判、或嘲笑。殊不知，他们根本就理解不了其中魅力与精彩。 每个人的心中都有一个区块链的样子，或邪恶、或美好、或欺骗、或精彩、或倾家荡产、或家财万贯、或等级森严、或自由平等。不同的是这个样子千差万别，相同的是他们都在为此不遗余力。 群雄逐鹿的大航海时代，谁最终会定义区块链未来的样子？]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[下一代WEB协议——IPFS(星际文件系统)]]></title>
    <url>%2F2018%2F09%2F10%2F%E4%B8%8B%E4%B8%80%E4%BB%A3WEB%E5%8D%8F%E8%AE%AE%E2%80%94%E2%80%94IPFS-%E6%98%9F%E9%99%85%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[简介1991年，最早版本的HTTP(超文本传输协议)协议发布, 正式当时这个不怎么起眼的网络协议吹响了互联网行业的号角，随后而来的二十多年，HTTP彻底成为了互联网领域网络协议的绝对霸主。 但是，正如圈内人所言，没有绝对安全的系统一样，也不存在绝对完美的协议。随着时代的发展，HTTP协议爆发出来各种问题，顶尖的工程师们对其缺点越来越不满，抱怨也日益增多。突出体现与以下几个方面 HTTP低效并且昂贵HTTP请求是从单一的计算机上下载文件，其产生的带宽费用要比基于P2P的分布式网络高出60%, ipfs通过P2P网络协议，除了能够节省带宽，而且能对数据进行备份保存。 人类的历史数据不能被永久保存，会被删除基于HTTP协议的web服务器，其平均的生命周期只有100天。我们之前访问的站点，一旦服务关闭，我们的数据将永久消失，试想一下，随着QQ宠物的关闭下线，我们再也找不回曾经那些美好的记忆了。 中心化的web服务让权利掌握在少数人手中网络已经称为了人类历史上最重要的发明之一，并且深深的影响着我们的生活。但是，不管我们是在淘宝开店还是在微信发表文章，我们都并不自由，核心的权利永远掌握在巨头的手中。 网络应用太依赖骨干网传统的应用保证高可用都是高度依赖骨干网络，IPFS支持创建具有多种弹性的网络，无论是否具有Internet骨干网络，都可以实现持久的高可用。 创新的火种永远不会被扑灭，正是基于以上的种种的抱怨与矛盾，IPFS诞生了。在2014年的5月，一位来自墨西哥的小伙子Juan Benet发明了IPFS。正如绝大多数天才一样，他也有着亮眼的履历与背景，毕业于举世闻名的斯坦福大学，在2015年参与了大名鼎鼎的Ycombinator计划，并成功创办了Protocol Lab实验室。 尽管如此，但以上种种都不是IPFS被世人所熟知的原因，尽管IPFS一开始的设计就号称是革命性的技术。 但在其诞生的前几年，并没有引起世人的关注。 相信对区块链有所关注的人们都知道，2017年在区块链领域是非同寻常的一年，比特币价格一度暴涨至2万美金，各种ICO项目层出不穷。 正是这一年，基于IPFS的区块链项目FileCoin诞生了。FileCoin在2017年8月创纪录地募集到了2.5亿美金，而这仅仅是在Token sale出售了10%的代币的情况下，这也意味着FoinCoin还未上线，市值就达到了惊人的25亿美金，虽然这一记录很快就被后来的EOS所超越，但其所取得的成绩也是有目共睹。可以说FoinCoin的成功极大地促进了IPFS技术的发展，越来越多的开发者加入进来贡献代码，其影响力正在以指数般的速度增长。 理论介绍IPFS是什么？打开ipfs的官网网站印入眼帘的几个大字，IPFS is the Distributed Web, 是的，在创始人严重其目的就是来挑战HTTP的霸主地位，定义下一代的web服务标准。但，随着社区的不断进化与创新，IPFS能干的事情已经隐隐超出了HTTP协议的范畴，除了传输其在存储领域也正闪耀了耀眼的光芒。当然，谁也无法把我历史的进程，IPFS最终能否像HTTP一样大方异彩还值得我们观察。但我相信IPFS，也正在践行着作为一个信仰者的使命。 前面提到IPFS的由来，其为了解决HTTP的痛点而来，所以IPFS有以下优点 高效而且廉价 记录永久保存 去中心化，机会均等 不依赖与主干网络，网络弹性 IPFS安装Go 安装go get github.com/ipfs/go-ipfs 源码安装 下载源码: 源码 解压 1tar xvfz go-ipfs.tar.gz 安装 12cd go-ipfs./install.sh 测试安装1ipfs --help 在终端有如下输出 Ipfs 初始化1ipfs init Quick Start既然知道了IPFS是革命性的技术，那么作为入门，我们首先来看看，如何使用ipfs，以及我们能用ipfs做什么？ 添加文件到ipfs12echo &quot;hello world&quot; &gt;helloipfs add hello 浏览文件1ipfs cat &lt;the-hash-you-got-here&gt; 添加一个文件夹12345mkdir foomkdir foo/barecho &quot;baz&quot; &gt; foo/bazecho &quot;baz&quot; &gt; foo/bar/bazipfs add -r foo 浏览123456ipfs ls &lt;the-hash-here&gt;ipfs ls &lt;the-hash-here&gt;/baripfs cat &lt;the-hash-here&gt;/bazipfs cat &lt;the-hash-here&gt;/bar/bazipfs cat &lt;the-hash-here&gt;/baripfs ls &lt;the-hash-here&gt;/baz 查看链接信息123ipfs refs &lt;the-hash-here&gt;ipfs refs -r &lt;the-hash-here&gt;ipfs refs --help 获取文件12ipfs get &lt;the-hash-here&gt; -o foo2diff foo foo2 IPFS对象123ipfs object get &lt;the-hash-here&gt;ipfs object get &lt;the-hash-here&gt;/foo2ipfs object --help Pin + GC12345ipfs pin add &lt;the-hash-here&gt;ipfs repo gcipfs ls &lt;the-hash-here&gt;ipfs pin rm &lt;the-hash-here&gt;ipfs repo gc 启动服务12ipfs daemon (in another terminal)ipfs id 网络1234(must be online)ipfs swarm peersipfs idipfs cat &lt;hash-of-remote-object&gt; 文件挂载1234(warning: fuse is finicky!)ipfs mountcd /ipfs/&lt;the-hash-here&gt;ls 工具12345ipfs versionipfs updateipfs commandsipfs config --helpopen http://localhost:5001/webui 浏览器webui http://localhost:5001/webui video http://localhost:8080/ipfs/QmVc6zuAneKJzicnJpfrqCH9gSy6bz54JhcypfJYhGUFQu/play#/ipfs/QmTKZgRNwDNZwHtJSjCp6r5FYefzpULfy37JvMt9DwvXse ###images http://localhost:8080/ipfs/QmZpc3HvfjEXvLWGQPWbHk3AjD5j8NEN4gmFN8Jmrd5g83/cs ###markdown renderer app http://localhost:8080/ipfs/QmX7M9CiYXjVeFnkfVGf3y5ixTZ2ACeSGyL1vBJY1HvQPp/mdown 总结在本节内容里面，我们介绍了IPFS以及IPFS的安装使用，在quick-start里面的命令建议大家全部敲一遍，熟悉下IPFS，当然，仅仅如此相信大家都不会满意，所以在下一节会用IPFS写一个个人博客系统。真正的体会以下IPFS的魅力，等大家对IPFS感兴趣之后，我们在深入，讲讲IPFS的原理以及源码。 参考 https://ipfs.io/docs/]]></content>
      <categories>
        <category>区块链</category>
        <category>IPFS</category>
      </categories>
      <tags>
        <tag>ipfs</tag>
        <tag>web</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈云计算及kubernetes容器部署]]></title>
    <url>%2F2018%2F09%2F10%2F%E6%B5%85%E8%B0%88%E4%BA%91%E8%AE%A1%E7%AE%97%E5%8F%8Akubernetes%E5%AE%B9%E5%99%A8%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Abstract：随着技术的发展与社会的进步，人们对资源的高效利用有了更为迫切的需求。当然IT行业也不例外。经历了过去数年间IT行业较为粗旷式的发展，近年来随着互联网、移动互联网的高速发展、成熟，IT资源的按需付费引起了各大厂商的热情关注，而云计算随之也进入大众的视野。尤其最近随着AWS、Google、ALIYUN推出云计算资源的按秒计费，让大众真正意识到将IT资源像用电、用水一样高效利用成为可能。正因如此，云计算正大放异彩，光芒越来越高涨！ 所以，如果数年之后Aliyun成为比水利水电局更大的组织，也不要有丝毫惊讶! !首先看两张图: Kubernetes这个名字起源于古希腊，是舵手的意思，所以它的Logo即像一张渔网，又像一个罗盘。google采用这个名字的一层深意就是：既然Docker把自己定义为驮着集装箱在大海上自由遨游的鲸鱼，那么google就要以Kubernetes掌舵大航海时代的话语权，“捕获”和“指引”这条鲸鱼按照“主人”设定的路线巡游，确保google倾力打造的新一代容器世界的宏伟蓝图顺利实现。然而无论是因为金钱还是局势，从昨天Docker官方宣布正式原生支持kubernetes开始，Kubernetes正式成为容器时代的海上霸主，当然kubernents最终是否能够一统江湖，还需要我们在座的各位来一起见证！ 一、 Docker是什么？ Docker 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的运行效率，降低了云计算资源供应的成本！ 使用 Docker，可以让应用的部署、测试和分发都变得前所未有的高效和轻松！ Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源)，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动开放容器联盟。 Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 3 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。 Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。 Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。 下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 二 、为什么要使用Docker？作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。 1.更高效的利用系统资源由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 2. 更快速的启动时间传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 容器的重置速度比虚拟机快9倍 容器的平均生存周期是 2.5 天，而传统的云虚拟机是 23 天。 容器编排对容器的生存周期有重要的影响，自动启动和关闭容器导致了更高的重置率。使用了编排引擎的企业，一般的容器存活时间不会超过 1 天，而没有使用编排引擎的企业，他们的容器平均存活时间为 5.5 天。 容器的短存活期和高密度意味着需要更好的基础设施监控。监控方案必须是基于主机的，而不是基于角色的。Docker 将促使监控方式不断地发生变化。 3.一致的运行环境开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题。 例如： 目前我们机器紧缺，需要在一台机上运行多个服务，但是这些服务用了不同的python版本（real 2.7 model 3.5） 如果不采用docker, 就需要virtualenv的虚拟化运行环境。但是系统级的服务还是会相互耦合，产生影响。但是如果利用docker 可以完全隔离开各个服务的运行。而且Datadog的调查报告显示，一台机器上一般会同时运行7个独立的容器。 4. 持续的部署和交付以我们为例， 测试人员一般需要测试机，有时间一个不同的client需要不同配置的多个测试环境，传统的方式搭建一套测试环境，即便是对环境部署很熟悉也至少需要3-5小时， 但是如果利用docker即使对项目完全不懂，也能分分钟部署完成，只需要一行简单的命令即可完成。 对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。 而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。 5. 更轻松的迁移由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。 6.更轻松的维护和扩展Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。 比如：基于docker的维护更多的是对编排文件的维护，传统的部署方式完全靠记忆， 不同的时间，不同的人，所采用的部署和维护方式千差万别， 但是采用docker 利用dockerfile docker-compose k8s等编排工具， 部署文档即文档， 不会因为时间与部署人员的变化发生变化。 7.越来越多的使用者 由 Datadog 监控的 15% 主机运行了 Docker . 两年前，Docker 只有 3% 的市场份额，现在增长到了 15%。从下图可以看到，Docker 增长率在一开始有所波动，但在 2015 年秋天开始趋于稳定。从那个时候开始，Docker 的采用率一直呈稳定的线性增长，由 Datadog 监控的六分之一机器几乎都运行了 Docker。 大公司仍然是主要的使用者大公司的增长趋于放缓，但在 Docker 方面，从 2015 年发布的第一份报告开始一直保持领先。一个公司使用的主机越多，就越有可能使用 Docker。将近 60% 的企业使用了 500 台或更多的主机，他们被归类为 Docker 玩家或 Docker 采用者。 据上一份报告显示，使用了大量主机的企业是推动 Docker 采用的主要力量，而最近的数据表明，使用了中等数量（100 到 499 台）主机的企业也成为重要的贡献者。大中型公司的采用率现在几乎趋于一致。 采用者的容器数量在 9 个月内增长到 5 倍从使用 Docker 的第 1 个月到第 9 个月，采用者的容器平均数量几乎增长到了原先的 5 倍。采用率呈线性增长，而且在第 10 个月后没有下降的势头。另一些数据表明，这种增长模式从上一份报告以来一直保持稳定。 最重要的是： 随着行业竞争进入尾声，谁能最大程度的节约资源、优化成本、提高运营效率，就能掌握主动，占据先机。 谁能最大化的利用现有生产力、扭亏为盈，就能笑到最后，一统天下！ Docker使用实战example： image （镜像）: container （容器）: registry （仓库）: 例子源码地址：https://github.com/csunny/kubernetes_deploy/tree/master/examples/mysql docker 让服务的发布运行变得非常简单，非常轻量，在任何环境，任何时间，我们只需要一份镜像，一份配置文件就可以发布我们的应用. docker 三剑客： docker-compose, docker-swarm, docker-machine. Kubernetes是什么？Kubernetes（K8s）是2014年Google发布的一个开源项目,Google 每周都会运行高达两亿的容器，并且在过去的十年间，他们一直都在使用容器. 在Google内部这个系统曾经叫做Borg，现在更名为Omega. kubernetes的主要功能就是容器管理平台，它提供了丰富的功能，例如resource utilization, high avaliablity, updates, patching, networking, service discovery, monitoring and logging. 为什么要用kubernetes目前主要的容器管理平台有 Swarm、Kubernetes、Mesos、 ECS 这里对几个平台做一个简单的比较： Kubernetes的架构及原理简介：Kubernetes APIServer核心功能是提供了各类资源对象（Pod，Rc， Service等）的增、删、改、查及Watch等Http Rest接口，成为集群内各个功能模块之间数据交互和通信的中心枢纽，是整个系统的数据总线和数据中心。除此之外，还有以下特性： 是集群的管理入口 是资源配额控制的入口 提供了完备的集群安全机制 Controller Manager 作为集群内部的管理中心，负责集群内的Node、Pod副本、服务端点（EndPoint）、命名空间（NameSpace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）等的管理，当某个Node意外Down 机时，Controller manager会及时发现此故障并执行自动化修复流程，确保集群始终处于预期的状态。 Controller Manager又 包含Rc Controlller，Node Controller等，此处不展开讲述。 Scheduler在整个系统中承担了“承上启下”的重要功能，“承上”是指负责接收Controller Maneger创建新的Pod，为其安排一个落脚点（根据调度算法计算在哪里创建对应的资源）“启下”是指安置工作完成后，目标Node上的kubelet服务进程接管后续工作，负责Pod的下半生命周期。 Kubelet，在每个Node上都会运行一个Kubelet服务进程，该进程用于处理Master节点下发到本节点的任务，管理Pod及Pod中的容器。每个kubelet进程会在ApiServer上注册自身信息，定期向Master节点汇报节点资源的使用情况，并通过cAdvisor监控容器和节点资源。 Kube-proxy是安装在节点上的反向代理，负责服务的负载均衡。当我们Serive的时候，我们首先会经过kube-proxy，然后由kube-proxy负载均衡到对应的服务。 当然还有一些安全机制以及网络原理，此处不一一讲述。感兴趣的读者可以阅读https://kubernetes.io/上的文档。 Kubernetes使用实践看的见的未来——THE TIME OF CONTAINER随着云计算1.0 进入尾声, 云计算2.0的时代正式到来，不仅像各个大厂如ALIYUN，AWS等在利用自己的技术积累大赚特赚，就连像easystack，daocloud， cloundIn这样的创业公司亦前仆后继，打算从中分一杯羹。可以说如今云计算的江湖正暗流涌动。当然，没有对比就没有伤害，云计算2.0已不再单单是技术层面的竞争了，不管是以华为为首的基于openstack开源技术的左派，还是以AWS为代表的自研云计算技术的右派，如今的竞争都已不再单单是技术层面的竞争了，更多的是数据的竞争，是行业解决方案的竞争，是如何更好的帮助传统行业业务落地与赋能的竞争。 说到这里，不得不深入的探讨一下目前整个云计算市场的商业格局了，可以说随着新零售、智能制造、LoT、AR/VR等的发展，云计算正在逐步成为一种基础的计算资源，一种基础设施。目前像AWS、Aliyun、Google、JD这样掌握了海量数据的互联网公司，都在利用自己的云计算资源+数据资源在给传统行业提供解决方案，以阿里云为主，Aliyun提出的口号是赋能传统企业，即利用自己在云计算方面的技术积累，为传统企业提供行业的解决方案，搭建适用于传统行业的混合云架构，可以说在这条路上，已经领先了绝大多数的云计算厂商，当然华为采取的手段也大同小异，由于华为起家于通信，可以说在硬件、传统制造领域有着无与伦比的优势，所以像中芯国际为代表的等一批制造厂商正在或者已经接入了华为的云计算平台。不同于大公司商业布局与角逐，很多创业小公司也在自己独有的一片天地中“喝酒吃肉”颇为滋润。当然，不像大公司一样全盘通吃，小公司更多的是在独有的一个领域的积累，帮助某一个细分的传统领域，提供解决方案与服务比如类似酷家乐这样的设计平台，类似的企业还有很多，有针对服装行业的，有针对餐饮的，4S店的等等。通常这一类的公司或者服务被称为“行业云”. 总之，云计算再怎么发展，都离不开一条亘古不变的规律，谁能提供更可靠、更高效、更实惠的服务，谁就能在这场角逐中站稳脚跟。相反，如果把云计算技术，容器技术当成是一种噱头或者是商业炒作，并不能优化资源，提高效率的话，终归会死的很惨。而我们作为这个时代的技术人，如果能借鉴他们的技术架构与方案，部署出适合自己的技术架构，为公司节约成本就显得颇为重要，且不说最终会节约多大的成本，单是技术的积累就值得我们花心思去尝试了，更何况尝试的代价也微乎其微。]]></content>
      <categories>
        <category>云计算</category>
        <category>Docker</category>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
</search>
